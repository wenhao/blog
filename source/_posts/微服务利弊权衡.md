title: 微服务利弊权衡
date: 2015-07-06 12:14:31
categories:
  - 翻译
tags: 
  - Martin Fowler
  - 微服务
toc: true
  
---

![微服务架构](/img/microservice.png)

一些开发团队意识到[微服务架构风格](http://martinfowler.com/articles/microservices.html)是解决大型单体架构的首选方案。同时某些团队也发现微服务架构会降低生产效率。与其他架构一样，微服务也具有其利与弊。决定在特定场景之下使用微服务架构之前了解这些还是很有必要的。

####微服务的优点...

* [高度的模块边界化](./微服务利弊权衡.md/#高度的模块边界化)：微服务促进系统模块化，特别是针对大型团队。
* [独立部署](./微服务利弊权衡.md/#独立部署)：微服务更容易部署，而且由于微服务大多是独立自主的，当它出错的时候不大可能引起整个系统崩溃。
* [技术架构多样性](./微服务利弊权衡.md/#技术架构多样性)：使用微服务你可以混用多种开发语言，开发框架和数据存储设备。

####微服务缺点...

* [分布式](./微服务利弊权衡.md/#分布式)：由于远程方法调用低效及出错风险极高，导致分布式系统很难开发。
* [最终一致性](./微服务利弊权衡.md/#最终一致性)：比起开发分布式系统，保持系统之间的高度一致性更加困难，它意味着每个人都必须关注系统的最终一致性。
* [运维复杂性](./微服务利弊权衡.md/#运维复杂性)：微服务经常更新并重新部署，所以你需要一个成熟的团队来管理这些微服务。

<!-- more -->

[总结](./微服务利弊权衡.md/#总结)

###高度的模块边界化

第一个优点是微服务使系统高度模块边界化。这是一个很重要的优点但同时也是很奇怪的一个，因为没有任何理由，理论上讲，为什么微服务应用对比大型单体应用要具有高度模块边界化特性。

我所说的高度模块边界化是什么意思呢？我想大部分人会赞同最好把软件分成不同的模块：应用程序之间相互耦合带来的复杂度。当你需要改变你系统的某一个部分使某个功能模块工作时，通常情况下，你只需要理解系统很小的一部分然后更改它，而且你能很容易就找到你需要更改的那一小部分。好的模块化结构在任何程序中都很有用，特别是在软件数量以指数级增长时更为重要。也许更为重要的是，应用程序随着团队开发越大越重要。

微服务的拥护者很快就提出[Conway法则](http://www.thoughtworks.com/insights/blog/demystifying-conways-law)，软件设计的架构，实际上反应了公司的组织与沟通架构。对于大型团队，特别是分布在不同地区的开发团队。比起大团队，小团队内部的沟通就没必要那么频繁而且更为正式，重新架构软件以适应这种组织结构就变得很重要了。微服务允许各个团队在某种沟通模式下维护自己相对独立的服务单元。

如我之前所说，没有任何理由为什么一个大型单体应用系统不应当具有一个好的模块式的架构。但是大多数人发现这种应用机构很少，因此[“大泥球”](https://en.wikipedia.org/wiki/Big_ball_of_mud)”任然是普遍使用的架构模型。这种普遍的痛点使得一部分团队转向微服务架构。模块之间解耦之所以可以工作是因为模块的边界减少了模块之间的引用。这样做是一个很有用的策略捷径帮助更快的构建产品功能，但是如果大范围使用却会破坏模块架构和减低团队的生产效率。把几个模块做成分开的服务使得之间的边界更加牢固，但是使它更难寻找痛点。

一种重要的方面是于持久层解耦。去数据中心化是微服务特征之一，它以为者每一个服务负责管理自己的数据库，其他服务必须通过此服务的公共API获取数据而不是直接访问数据库。这就避免了[数据库集成](http://martinfowler.com/bliki/IntegrationDatabase.html)，它是大型系统中耦合最主要的因数。

值得强调的是在大型单体应用中也可以创建坚固的模块边界，但是需要严格的纪律做支撑。同样微服务也可以开发成“大泥球”，但是它需要更多的工作量在做错误的事。以我之见，使用微服务增加了获取更好模块化架构的可能性。如果你对你们团队的纪律规则有信心，很可能获取那种优势，但是团队不断成长变大之后保持这种纪律规则就愈发困难，维护模块边界就变得更为重要。

如果你创建了错误的边界，这种优势就可能变成一种阻碍。这就是[先开发单体应用](http://martinfowler.com/bliki/MonolithFirst.html)策略的两个主要原因之一，也就是为什么那些更倾向于[提早做微服务](http://martinfowler.com/articles/dont-start-monolith.html)时必须先理解某个领域模型。

然而对于此的警告我还没没有说完。只有在系统维护一段时间之后你才能得出结论这个是否是好的模块化系统。同理，只有在我们使用微服务数年之后，我们才能知道微服务是否是引领更好的系统模块化的解决方案。此外，更早的采用此架构就更加明智，因此，在一般团队开发的微服务之后，收益模块化的优势往往有些延迟。即使那样，我们不得不接受一般团队开发的一般软件，不是与优秀的团队比较结果而是我们不得不与使用单体应用架构开发的软件做比较——这是一种微妙的对照评估。

我将要说的都是别人早期实践过这种架构风格的一些真实问题，他们的判断是越早维护他们的模块越有意义。

有个案例研究特别有趣。某个团队做了错误的选择了使用微服务架构，但是根据文章[微服务代价](http://martinfowler.com/bliki/MicroservicePremium.html)来说他们的系统还不够复杂。这个项目出现了问题必须挽救，所以大部分人又加入了此项目。这种情况下，微服务架构可以帮上忙，因为比起单体系统来说微服务可以更容易消化大部分开发人员而且可以把大团队平均分配到各个团队。最终，这个团队效率高于开发单体应用，使团队能够追赶进度。但是任然有负面的影响，比起开发单体应用来说，微服务会花费更多的时间开发同样的功能，但是微服务架构在后期也可以提高效率。

###分布式

微服务使用分布式系统来提高模块化。但是分布式系统有个很大的缺点，这个缺点正式“分布式的”。一旦你选择了分布式架构，你就会面临太多的复杂性问题。[我不认为微服务社区会天真的以为分布式对象会带来额外的成本](http://martinfowler.com/articles/distributed-objects-microservices.html)，但是这种复杂度任然存在。

第一个问题是性能。你不得不正视功能之间调用的性能最近成为了热点问题，但是远程调用速度很慢。如果你的服务调用多个远程服务，而且每一个服务又调用其他服务，所有的响应时间加起来会变成可怕的潜在隐患。

当然你可以通过某种方式缓解这个问题。首先你可以增加被调用服务的粒度，你可以只做一些服务。这会使编程模型变得复杂，你不得不考虑批量处理服务之间的调用。这种方法只能达到这种地步，因为一次性你不得不调用所有的关联服务。

第二种缓解方式是使用异步。如果并行调用六个异步方法，你最慢的速度决定于这六个异步调用中最慢的那个而不是六个异步调用时间总和。这种方式可以获得很大的性能改进，但是同时也会导致另外一个我们所知的问题。异步编程很难：难于实现，也难于调试。但是我听说过的大部分微服务案例表明做异步只是为了达到可以接受的性能指标。

性能之后是可靠性。你期待正在执行的功能调用能够工作，但是远程方法调用任何时候都可能失败。如果有大量的微服务的话，失败的几率就更大。聪敏的开发人员早就意识到这一点并及早做[故障设计](http://martinfowler.com/articles/microservices.html#DesignForFailure)。庆幸的是异步调用的策略也同样可以提高故障处理的弹性。但是这并起不了太大作用，你任然需要做其他的工作来找出具体是哪一个远程调用失败了。

这只是[分布式计算的谬误](http://www.infoq.com/cn/news/2009/06/fallacies-distributed-computing)提到的前两点。

对于这个问题有一些说明。首先，大部分问题都是随着单体应用不断扩大而导致。某些单体应用都是相对独立的，通常情况下，大部分工作在遗留系统之上。通过网络远程的方式与这些系统交互同样会遇到这些问题。这就是为什么大多数人倾向于更早的使用微服务架构来处理各网络服务之间的信息交付。这种时候经验就很有帮助了，一个有此经验的团队就能更好的解决这些分布式的问题。

但是分布式始终会是个成本问题。每次谈论分布式问题我都有点勉强，因为大多数人在使用分布式机构之前低估了它带来的问题。

###最终一致性

我确认你也会认同访问网站需要一些耐心。你更新某些东西，如果你重新加载页面，想要更新的数据就丢失了。也许等几分钟之后，再次重新加载页面，更新的内容又出现了。

这种实用性很差的问题令人讨厌，这就是关系到最终一致性问题。你的更新操作可能被粉色节点处理，但是你的请求可能被绿色节点处理。直到绿色节点从粉色节点获取更新的结果，你陷入了不一致的情况。最总内容会达成一致，但是在这个过程中你会好奇是不是什么地方出了问题。

微服务由于具有其去数据中心化的特点，使用它就会造成最终一致性问题。对于单体应用来说，你可以在一个事务期间做多件事。而微服务需要更新多个不同的资源，分布式事务是很讨厌的(合理)。开发人员需要重视一致性问题，为了避免后悔，在做任何编码之间，试图搞清楚如何找出哪些过程是不同步的。

单体应用同样具有这些问题。在系统不断变大后，需要更多的做缓存来提高性能，但是缓存失效又是[另外一个问题](http://martinfowler.com/bliki/TwoHardThings.html)。大多数应用程序都需要[离线锁](http://martinfowler.com/eaaCatalog/optimisticOfflineLock.html)以避免长时间存在的数据库事务。外部系统需要更新但是又不能拥有事务处理。业务流程的不一致性问题没有你想的那么严重，因为业务通常考虑到了这点(业务流程本身就先理解分布式系统[CAP原理](http://ksat.me/a-plain-english-introduction-to-cap-theorem/))。

如其他分布式系统问题一样，单体应用也没办法完全避免不一致的问题，但是这种问题要少得多，尤其是单体应用够小的话。

###独立部署

模块边界话和分布式系统的权衡困扰了我整个职业生涯。但是有一件事明显改变，在过去十年里，存在专门负责发布到产品环境的职位。在二十世纪，产品环境发布任然是偶尔而且最痛苦的过程，通常白天黑夜两班倒只是为了把软件放到某个地方可以工作。但是如今，成熟的团队可以频繁的部署的产品环境，许多组织开始实践[持续交付](http://martinfowler.com/bliki/ContinuousDelivery.html)，使得他们可以一天多次发布到产品环境。

这种改变对整个环境产业具有重大的意义，同样它也深远的影响着微服务。引入微服务就是为了解决部署大型单体应用的复杂度，即便是修改单体应用很小的一部分也可能导致整个部署失败。微服务的一个主要原则就是[服务即组件](http://martinfowler.com/articles/microservices.html#ComponentizationViaServices)，它们可以独立的部署。也就是说当你修改某个服务时，你只需要测试然后部署这个服务就够了。即便你搞砸了这个服务，也不会使整个系统崩溃。毕竟，由于需要故障设计，即使你的某个组件完全失败掉也不应当使系统的其他部分停止工作。

这是一种双向选择的关系。由于大部分微服务需要频繁的部署，所以你也许要同时兼顾部署。这就是为什么快速应用部署和快速基础设施创建是[微服务的前提](http://martinfowler.com/bliki/MicroservicePrerequisites.html)。比起这些基础的要求只要，你需要的是做持续交付。


###运维复杂性


###技术架构多样性


###次要因素


###总结


####脚注


####延伸阅读


####鸣谢